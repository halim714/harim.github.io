# 파일명 규칙 마이그레이션 계획서

## 개요

**목표**: Git 히스토리 보존과 사용자 친화성을 동시에 달성하는 파일명 체계 구축

**현재**: `{slug}.md`  
**변경**: `{YYYYMMDD}-{slug}-{uuid8}.md`

---

## 1. 배경 및 동기

### 현재 문제점

1. **Git 히스토리 단절**: 제목 변경 시 파일명이 바뀌어 히스토리가 끊김
2. **내용 대폭 수정 시 위험**: Git이 "새 파일"로 인식할 가능성
3. **로컬 내보내기 시 불명확**: 파일명만으로 언제 작성했는지 알 수 없음

### 해결 방향

- **UUID**: Git 히스토리 추적의 앵커 역할 (불변)
- **날짜**: 시간적 맥락 제공, 파일 정렬 용이 (불변)
- **Slug**: 인간 가독성 (가변, 제목 따라 변경)

---

## 2. 핵심 원칙

1. **기존 문서 호환성**: 이미 저장된 문서가 깨지지 않아야 함
2. **점진적 마이그레이션**: 새 문서부터 적용, 기존 문서는 수정 시 변환
3. **사용자 무인식**: 에디터에서는 제목만 표시
4. **Git 히스토리 보존**: UUID로 추적 연속성 확보

---

## 3. 파일명 패턴 정의

### 패턴

```
{YYYYMMDD}-{truncated-slug}-{uuid8}.md
```

### 구성 요소

| 구성 | 규칙 | 가변성 | 예시 |
|------|------|--------|------|
| `YYYYMMDD` | 최초 생성일 | 불변 | `20240116` |
| `slug` | 현재 제목의 slugify | 가변 | `나의-생각` |
| `uuid8` | docId 앞 8자리 | 불변 | `a1b2c3d4` |

### 제한 사항

- **Slug 최대 길이**: 40자 (한글 기준, URL 인코딩 고려)
- **총 파일명 길이**: 약 61자 (Windows/Git 호환)

### 생성 예시

```
제목: "인공지능 시대에 신뢰를 구축하는 방법"
docId: a1b2c3d4-e5f6-7890-abcd-1234567890ef
생성일: 2024-01-16

→ 파일명: 20240116-인공지능-시대에-신뢰를-구축하는-a1b2c3d4.md
          (40자 초과 시 단어 경계에서 절삭)
```

---

## 4. 레이어별 표시 규칙

| 레이어 | 표시 내용 | 데이터 출처 |
|--------|-----------|-------------|
| GitHub 저장소 | `20240116-나의-생각-a1b2c3d4.md` | 파일명 |
| 에디터 문서 목록 | "나의 생각" | Front Matter `title` |
| 에디터 편집 화면 | "나의 생각" | Front Matter `title` |
| 블로그 URL | `/posts/my-thoughts/` | Front Matter `permalink` |
| 로컬 내보내기 | `20240116-나의-생각-a1b2c3d4.md` | 파일명 |

---

## 5. Front Matter 스키마

### 필수 필드

```yaml
---
docId: a1b2c3d4-e5f6-7890-abcd-1234567890ef
title: 나의 생각
createdAt: 2024-01-16T10:30:00Z
updatedAt: 2024-01-16T14:00:00Z
---
```

### 선택 필드 (향후 확장)

```yaml
---
slug: my-thoughts           # 커스텀 URL slug
permalink: /posts/my-thoughts/  # 블로그 URL 오버라이드
tags: [철학, 성장]
status: draft | published
---
```

---

## 6. 마이그레이션 시나리오

### 시나리오 A: 새 문서 생성

1. 사용자가 "새 글" 클릭
2. UUID 생성 → `a1b2c3d4-...`
3. 오늘 날짜 → `20240116`
4. 초기 제목 → "새 메모" → slug: `새-메모`
5. **파일명**: `20240116-새-메모-a1b2c3d4.md`

### 시나리오 B: 기존 문서 수정 (구 패턴)

1. 기존 파일: `my-old-post.md`
2. 수정 후 저장 시:
   - Front Matter `createdAt` 추출 → `20230501`
   - docId 확인/생성 → `b2c3d4e5-...`
   - 현재 제목 slug화
3. **새 파일명**: `20230501-my-old-post-b2c3d4e5.md`
4. 구 파일 삭제

### 시나리오 C: 제목 변경

1. 기존: `20240116-처음-생각-a1b2c3d4.md`
2. 제목을 "발전된 생각"으로 변경
3. **새 파일명**: `20240116-발전된-생각-a1b2c3d4.md`
4. 구 파일 삭제
5. Git: UUID 동일 + 내용 유사 → rename으로 인식

---

## 7. 영향 범위

### 변경 필요

| 파일 | 변경 내용 |
|------|-----------|
| `src/utils/slugify.js` | 파일명 생성 함수 추가 |
| `src/utils/storage-client.js` | `_savePostToGitHub`에 새 패턴 적용 |
| `src/components/Editor.jsx` | 초기 파일명 설정 로직 |

### 변경 불필요

| 파일 | 이유 |
|------|------|
| `src/services/github.js` | 파일명을 받아서 처리할 뿐 |
| `src/services/publish.js` | 파일명 그대로 사용 |
| UI 컴포넌트들 | `title` 표시만 함 |

---

## 8. 구현 순서

| 순서 | 작업 | 위험도 | 예상 시간 |
|------|------|--------|-----------|
| 1 | `slugify.js`에 `generateFilename()` 함수 추가 | 🟢 낮음 | 30분 |
| 2 | `_savePostToGitHub`에 새 패턴 적용 | 🟡 중간 | 1시간 |
| 3 | 마이그레이션 로직 (구→신 패턴 감지/변환) | 🟡 중간 | 1시간 |
| 4 | `getPostList` 파일명 파싱 호환성 확보 | 🟢 낮음 | 30분 |
| 5 | 테스트 및 검증 | 🟢 낮음 | 1시간 |

---

## 9. 검증 체크리스트

### 기능 테스트

- [ ] 새 문서 생성 → 새 패턴 파일명 생성됨
- [ ] 기존 문서 열기 → 정상 로드
- [ ] 기존 문서 저장 → 새 패턴으로 마이그레이션
- [ ] 제목 변경 → 파일명 slug 업데이트, 구 파일 삭제
- [ ] 에디터 목록 → 제목만 표시 (파일명 안 보임)
- [ ] 동기화 → SHA 정상 추적

### 호환성 테스트

- [ ] 구 패턴 파일 인식
- [ ] 혼합 상태 (구+신 패턴) 정상 작동
- [ ] Windows 경로 길이 (200자 이내)
- [ ] Git rename 감지 (`git log --follow` 테스트)

---

## 10. 롤백 계획

### 코드 롤백

```bash
git reset --hard {이전커밋}
git push origin main --force
```

### 데이터 복구

1. 새 패턴 파일에서 Front Matter `title` 추출
2. 구 패턴으로 rename: `{slug}.md`
3. Front Matter는 보존되어 있으므로 데이터 손실 없음

---

## 11. 예상 효과

| 항목 | Before | After |
|------|--------|-------|
| Git 히스토리 | 제목 변경 시 단절 위험 | UUID로 영구 연결 |
| 로컬 내보내기 | slug만으로 불명확 | 날짜+제목+ID로 명확 |
| 파일 정렬 | 무작위 | 날짜순 자동 정렬 |
| 에디터 표시 | 제목 (변경 없음) | 제목 (변경 없음) |
| 신뢰의 맥락 | 히스토리 단절 가능 | 변화 과정 완전 추적 |

---

## 12. 관련 문서

- [LAYOUT_IMPROVEMENT_PLAN.md](./LAYOUT_IMPROVEMENT_PLAN.md) - 에디터 레이아웃 개선 계획
- 향후: 자동 저장 최적화 계획

---

**작성일**: 2026-01-16  
**상태**: 계획 수립 완료, 구현 대기
