Miki Editor ì™„ì „ ì„œë²„ë¦¬ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜ ê³„íš v2.0
í•µì‹¬ ëª©í‘œ (11/28 ë°ë“œë¼ì¸)
text
âœ… ì„œë²„ë¦¬ìŠ¤ ì•„í‚¤í…ì²˜ (Express ì œê±°, Vercel Functionsë§Œ ì‚¬ìš©)
âœ… ë‘ ì €ì¥ì†Œ êµ¬ì¡° ìœ ì§€ (í”„ë¼ì´ë¹— miki-data + í¼ë¸”ë¦­ username.github.io)
âœ… Publish ê¸°ëŠ¥ ì™„ì „ êµ¬í˜„ (í”„ë¡ íŠ¸ì—”ë“œì—ì„œ ë‘ ì €ì¥ì†Œ ë™ì‹œ ê´€ë¦¬)
âœ… íŒŒì¼ëª… Slugify (ì œëª© â†’ URL ì¹œí™”ì  íŒŒì¼ëª…)
âœ… ë©”íƒ€ë°ì´í„°/ë§í¬ ê´€ë¦¬ ë¡œì§ í”„ë¡ íŠ¸ì—”ë“œ ì´ì‹
âœ… ê¸°ì¡´ UX/props/í•¨ìˆ˜/ì˜ì¡´ì„± 100% ë³´ì¡´
ğŸ“ ìµœì¢… íŒŒì¼ êµ¬ì¡°
text
miki-editor/
â”œâ”€â”€ api/
â”‚   â””â”€â”€ auth/
â”‚       â””â”€â”€ callback.js              âœ¨ OAuth í† í° êµí™˜ (ìœ ì¼í•œ ì„œë²„ë¦¬ìŠ¤ í•¨ìˆ˜)
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ auth.js                  âœ¨ ì¸ì¦ ê´€ë¦¬
â”‚   â”‚   â”œâ”€â”€ github.js                âœ¨ GitHub API ë˜í¼ (ì˜¨ë³´ë”© + CRUD)
â”‚   â”‚   â”œâ”€â”€ publish.js               âœ¨ ì‹ ê·œ: ë°°í¬ ë¡œì§ (í”„ë¼ì´ë¹— â†’ í¼ë¸”ë¦­ ë³µì‚¬)
â”‚   â”‚   â””â”€â”€ metadata.js              âœ¨ ì‹ ê·œ: ë©”íƒ€ë°ì´í„° íŒŒì‹±/ìƒì„±
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ slugify.js               âœ¨ ì‹ ê·œ: ì œëª© â†’ íŒŒì¼ëª… ë³€í™˜
â”‚   â”‚   â”œâ”€â”€ markdown.js              âœ¨ ì‹ ê·œ: ë§ˆí¬ë‹¤ìš´ íŒŒì‹±/ë§í¬ ì¶”ì¶œ
â”‚   â”‚   â”œâ”€â”€ storage-client.js        ğŸ”§ ìˆ˜ì •: ë‘ ì €ì¥ì†Œ ê´€ë¦¬
â”‚   â”‚   â””â”€â”€ database.js              âœ… ê·¸ëŒ€ë¡œ: IndexedDB
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ LoginPage.jsx            ğŸ”§ ìˆ˜ì •
â”‚   â”‚   â”œâ”€â”€ CallbackPage.jsx         âœ¨ ì‹ ê·œ
â”‚   â”‚   â”œâ”€â”€ OnboardingSetup.jsx      ğŸ”§ ìˆ˜ì •
â”‚   â”‚   â””â”€â”€ Editor.jsx               ğŸ”§ ìˆ˜ì •: Publish ë²„íŠ¼ ì—°ê²°
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ useDocuments.js          ğŸ”§ ìˆ˜ì •: slugify ì ìš©
â”‚   â”‚   â”œâ”€â”€ useAutoSave.js           âœ… ê·¸ëŒ€ë¡œ
â”‚   â”‚   â””â”€â”€ usePublish.js            âœ¨ ì‹ ê·œ: Publish í›…
â”‚   â””â”€â”€ App.jsx                      ğŸ”§ ìˆ˜ì •
â””â”€â”€ vercel.json                      âœ¨ ì‹ ê·œ
ğŸ”¥ Phase 0: ìƒˆë¡œìš´ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ (ë°±ì—”ë“œ ë¡œì§ ì´ì‹)
1. Slugify í•¨ìˆ˜
íŒŒì¼: src/utils/slugify.js âœ¨ ì‹ ê·œ

javascript
// src/utils/slugify.js
/**
 * ì œëª©ì„ URL ì¹œí™”ì ì¸ íŒŒì¼ëª…ìœ¼ë¡œ ë³€í™˜
 * ì˜ˆ: "ë‚˜ì˜ ì²« ë²ˆì§¸ ë©”ëª¨" â†’ "ë‚˜ì˜-ì²«-ë²ˆì§¸-ë©”ëª¨"
 */
export function slugify(text) {
  if (!text || typeof text !== 'string') {
    return `memo-${Date.now()}`;
  }

  return text
    .trim()
    .toLowerCase()
    // í•œê¸€, ì˜ë¬¸, ìˆ«ì, í•˜ì´í”ˆ, ê³µë°±ë§Œ ìœ ì§€
    .replace(/[^a-z0-9ê°€-í£\s-]/g, '')
    // ê³µë°±ì„ í•˜ì´í”ˆìœ¼ë¡œ
    .replace(/\s+/g, '-')
    // ì—°ì†ëœ í•˜ì´í”ˆì„ í•˜ë‚˜ë¡œ
    .replace(/-+/g, '-')
    // ì•ë’¤ í•˜ì´í”ˆ ì œê±°
    .replace(/^-+|-+$/g, '')
    // ë¹„ì–´ìˆìœ¼ë©´ íƒ€ì„ìŠ¤íƒ¬í”„
    || `memo-${Date.now()}`;
}

/**
 * ê³ ìœ í•œ íŒŒì¼ëª… ìƒì„± (ì¶©ëŒ ë°©ì§€)
 */
export function generateUniqueFilename(title, existingFiles = []) {
  let slug = slugify(title);
  let counter = 1;
  let filename = `${slug}.md`;

  while (existingFiles.includes(filename)) {
    filename = `${slug}-${counter}.md`;
    counter++;
  }

  return filename;
}
2. ë§ˆí¬ë‹¤ìš´ ìœ í‹¸ë¦¬í‹°
íŒŒì¼: src/utils/markdown.js âœ¨ ì‹ ê·œ

javascript
// src/utils/markdown.js
/**
 * ë§ˆí¬ë‹¤ìš´ì—ì„œ ì œëª© ì¶”ì¶œ (# í—¤ë” ìš°ì„ )
 */
export function extractTitle(markdown) {
  if (!markdown) return 'ìƒˆ ë©”ëª¨';

  // ì²« ë²ˆì§¸ # í—¤ë” ì°¾ê¸°
  const headerMatch = markdown.match(/^#\s+(.+)$/m);
  if (headerMatch) {
    return headerMatch[1].trim();
  }

  // í—¤ë”ê°€ ì—†ìœ¼ë©´ ì²« ì¤„ ì‚¬ìš© (50ì ì œí•œ)
  const firstLine = markdown.split('\n')[0]?.trim() || '';
  if (!firstLine) return 'ìƒˆ ë©”ëª¨';

  return firstLine
    .replace(/^#+\s*/, '') // í—¤ë” ë§ˆì»¤ ì œê±°
    .replace(/\*\*(.*?)\*\*/g, '$1') // ë³¼ë“œ ì œê±°
    .replace(/\*(.*?)\*/g, '$1') // ì´íƒ¤ë¦­ ì œê±°
    .replace(/`(.*?)`/g, '$1') // ì¸ë¼ì¸ ì½”ë“œ ì œê±°
    .replace(/\[(.*?)\]\((.*?)\)/g, '$1') // ë§í¬ ì œê±°
    .slice(0, 50)
    .trim()
    || 'ìƒˆ ë©”ëª¨';
}

/**
 * ë§ˆí¬ë‹¤ìš´ì—ì„œ ë‚´ë¶€ ë§í¬ ì¶”ì¶œ
 * [[ë¬¸ì„œID]] í˜•ì‹ì˜ ìœ„í‚¤ ë§í¬
 */
export function extractInternalLinks(markdown) {
  if (!markdown) return [];

  const linkPattern = /\[\[([^\]]+)\]\]/g;
  const links = [];
  let match;

  while ((match = linkPattern.exec(markdown)) !== null) {
    links.push(match[1].trim());
  }

  return [...new Set(links)]; // ì¤‘ë³µ ì œê±°
}

/**
 * ë§ˆí¬ë‹¤ìš´ì—ì„œ íƒœê·¸ ì¶”ì¶œ
 * #íƒœê·¸ í˜•ì‹
 */
export function extractTags(markdown) {
  if (!markdown) return [];

  const tagPattern = /#([a-zA-Zê°€-í£0-9_-]+)/g;
  const tags = [];
  let match;

  while ((match = tagPattern.exec(markdown)) !== null) {
    tags.push(match[1]);
  }

  return [...new Set(tags)]; // ì¤‘ë³µ ì œê±°
}
3. ë©”íƒ€ë°ì´í„° ê´€ë¦¬
íŒŒì¼: src/services/metadata.js âœ¨ ì‹ ê·œ

javascript
// src/services/metadata.js
import { extractTitle, extractInternalLinks, extractTags } from '../utils/markdown';

/**
 * Front Matter ìƒì„± (Jekyllìš©)
 */
export function generateFrontMatter(document) {
  const title = document.title || extractTitle(document.content);
  const tags = document.tags || extractTags(document.content);
  const date = document.publishedAt || new Date().toISOString();

  return `---
layout: post
title: "${title.replace(/"/g, '\\"')}"
date: ${date.split('T')[0]}
categories: ${tags.length > 0 ? tags.join(' ') : 'general'}
tags: [${tags.join(', ')}]
---

`;
}

/**
 * ë¬¸ì„œ ë©”íƒ€ë°ì´í„° ì¶”ì¶œ
 */
export function extractMetadata(markdown) {
  return {
    title: extractTitle(markdown),
    internalLinks: extractInternalLinks(markdown),
    tags: extractTags(markdown),
    wordCount: markdown.split(/\s+/).length,
    characterCount: markdown.length,
    lastModified: new Date().toISOString()
  };
}

/**
 * Publishìš© ë§ˆí¬ë‹¤ìš´ ë³€í™˜
 * (Front Matter ì¶”ê°€ + ë‚´ë¶€ ë§í¬ ë³€í™˜)
 */
export function prepareForPublish(document) {
  const frontMatter = generateFrontMatter(document);
  let content = document.content;

  // ë‚´ë¶€ ë§í¬ë¥¼ Jekyll ë§í¬ë¡œ ë³€í™˜
  // [[ë¬¸ì„œID]] â†’ [ë¬¸ì„œID](/posts/ë¬¸ì„œID)
  content = content.replace(/\[\[([^\]]+)\]\]/g, '[$1](/posts/$1)');

  return frontMatter + content;
}
ğŸ”¥ Phase 1: Publish ì„œë¹„ìŠ¤ (í•µì‹¬!)
íŒŒì¼: src/services/publish.js âœ¨ ì‹ ê·œ

javascript
// src/services/publish.js
import { AuthService } from './auth';
import { GitHubService } from './github';
import { prepareForPublish } from './metadata';
import { slugify } from '../utils/slugify';

/**
 * Publish Service
 * í”„ë¼ì´ë¹— ì €ì¥ì†Œ(miki-data) â†’ í¼ë¸”ë¦­ ì €ì¥ì†Œ(username.github.io) ë°°í¬
 */
export class PublishService {
  constructor(token) {
    this.github = new GitHubService(token);
    this.username = null;
  }

  async initialize() {
    this.username = await this.github.setUsername();
  }

  /**
   * ë‹¨ì¼ ë¬¸ì„œ ë°°í¬
   */
  async publishDocument(document) {
    await this.initialize();

    // 1. ì œëª©ìœ¼ë¡œ íŒŒì¼ëª… ìƒì„±
    const slug = slugify(document.title);
    const date = new Date().toISOString().split('T')[0];
    const filename = `${date}-${slug}.md`; // Jekyll í˜•ì‹: YYYY-MM-DD-title.md

    // 2. Jekyllìš© ë§ˆí¬ë‹¤ìš´ ìƒì„± (Front Matter í¬í•¨)
    const publishContent = prepareForPublish(document);

    // 3. í”„ë¼ì´ë¹— ì €ì¥ì†Œì— ë¨¼ì € ì €ì¥ (ì›ë³¸)
    const privatePath = `miki-editor/posts/${document.id}.md`;
    await this.github.createOrUpdateFile(
      'miki-data',
      privatePath,
      document.content,
      `Update ${document.title}`,
      document.sha
    );

    // 4. í¼ë¸”ë¦­ ì €ì¥ì†Œì— ë°°í¬ (Jekyll í˜•ì‹)
    const publicPath = `_posts/${filename}`;
    const publicSha = await this.github.createOrUpdateFile(
      `${this.username}.github.io`,
      publicPath,
      publishContent,
      `Publish: ${document.title}`
    );

    return {
      success: true,
      privateRepo: 'miki-data',
      publicRepo: `${this.username}.github.io`,
      publicPath,
      publicUrl: `https://${this.username}.github.io/${slug}`,
      estimatedDeployTime: '1-2 minutes' // GitHub Pages ë¹Œë“œ ì‹œê°„
    };
  }

  /**
   * ë°°í¬ ì·¨ì†Œ (í¼ë¸”ë¦­ ì €ì¥ì†Œì—ì„œë§Œ ì‚­ì œ)
   */
  async unpublishDocument(document) {
    await this.initialize();

    const slug = slugify(document.title);
    const date = document.publishedAt?.split('T')[0] || new Date().toISOString().split('T')[0];
    const filename = `${date}-${slug}.md`;
    const publicPath = `_posts/${filename}`;

    // í¼ë¸”ë¦­ ì €ì¥ì†Œì—ì„œ íŒŒì¼ ì‚­ì œ
    try {
      const { data } = await this.github.octokit.rest.repos.getContent({
        owner: this.username,
        repo: `${this.username}.github.io`,
        path: publicPath
      });

      await this.github.octokit.rest.repos.deleteFile({
        owner: this.username,
        repo: `${this.username}.github.io`,
        path: publicPath,
        message: `Unpublish: ${document.title}`,
        sha: data.sha
      });

      return { success: true };
    } catch (error) {
      if (error.status === 404) {
        return { success: true, message: 'Already unpublished' };
      }
      throw error;
    }
  }

  /**
   * ë°°í¬ ìƒíƒœ í™•ì¸
   */
  async checkPublishStatus(document) {
    await this.initialize();

    const slug = slugify(document.title);
    const date = document.publishedAt?.split('T')[0] || new Date().toISOString().split('T')[0];
    const filename = `${date}-${slug}.md`;
    const publicPath = `_posts/${filename}`;

    try {
      await this.github.octokit.rest.repos.getContent({
        owner: this.username,
        repo: `${this.username}.github.io`,
        path: publicPath
      });
      return { isPublished: true, publicUrl: `https://${this.username}.github.io/${slug}` };
    } catch (error) {
      if (error.status === 404) {
        return { isPublished: false };
      }
      throw error;
    }
  }
}
ğŸ”¥ Phase 2: storage-client.js ì—…ë°ì´íŠ¸ (Slugify ì ìš©)
íŒŒì¼: src/utils/storage-client.js ğŸ”§ ìˆ˜ì •

javascript
// src/utils/storage-client.js
import { AuthService } from '../services/auth';
import { GitHubService } from '../services/github';
import { slugify, generateUniqueFilename } from './slugify';
import { extractTitle, extractMetadata } from '../utils/markdown';

const getGithub = async () => {
  const token = AuthService.getToken();
  if (!token) throw new Error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.');
  const github = new GitHubService(token);
  await github.setUsername();
  return github;
};

const decodeContent = (base64) => {
  try {
    return decodeURIComponent(escape(window.atob(base64)));
  } catch (e) {
    return window.atob(base64);
  }
};

export const storage = {
  async getPostList() {
    const github = await getGithub();
    try {
      const files = await github.getFiles('miki-data', 'miki-editor/posts');
      
      if (!Array.isArray(files)) return [];
      
      return files
        .filter(f => f.name && f.name.endsWith('.md'))
        .map(f => ({
          id: f.name.replace('.md', ''),
          title: f.name.replace('.md', '').replace(/-/g, ' '), // ì„ì‹œ ì œëª©
          updatedAt: new Date().toISOString(),
          size: f.size,
          sha: f.sha,
          path: f.path
        }));
    } catch (error) {
      console.error('Failed to fetch post list:', error);
      return [];
    }
  },

  async getPost(id) {
    const github = await getGithub();
    const file = await github.getFile('miki-data', `miki-editor/posts/${id}.md`);
    const content = decodeContent(file.content);
    
    // ë©”íƒ€ë°ì´í„° ì¶”ì¶œ
    const metadata = extractMetadata(content);
    
    return {
      id: id,
      title: metadata.title,
      content: content,
      sha: file.sha,
      metadata,
      updatedAt: new Date().toISOString()
    };
  },

  async savePost(post) {
    const github = await getGithub();
    
    // âœ… Slugify ì ìš©: ì œëª© â†’ íŒŒì¼ëª…
    const title = post.title || extractTitle(post.content);
    const slug = slugify(title);
    
    // ê¸°ì¡´ íŒŒì¼ ëª©ë¡ ì¡°íšŒ (ì¤‘ë³µ ë°©ì§€)
    const existingFiles = await this.getPostList();
    const existingFilenames = existingFiles.map(f => `${f.id}.md`);
    
    // ê³ ìœ í•œ íŒŒì¼ëª… ìƒì„±
    const filename = generateUniqueFilename(slug, existingFilenames);
    const id = filename.replace('.md', '');
    
    // íŒŒì¼ ì €ì¥
    const sha = await github.createOrUpdateFile(
      'miki-data',
      `miki-editor/posts/${filename}`,
      post.content || '',
      `Create ${title}`
    );
    
    return { 
      ...post, 
      id, 
      title,
      sha,
      metadata: extractMetadata(post.content || '')
    };
  },

  async updatePost(id, post) {
    const github = await getGithub();
    const filename = `${id}.md`;
    
    const title = post.title || extractTitle(post.content);
    
    const sha = await github.createOrUpdateFile(
      'miki-data',
      `miki-editor/posts/${filename}`,
      post.content || '',
      `Update ${title}`,
      post.sha
    );
    
    return { 
      ...post, 
      id, 
      title,
      sha,
      metadata: extractMetadata(post.content || '')
    };
  },

  async deletePost(id) {
    const github = await getGithub();
    const filename = `${id}.md`;
    const file = await github.getFile('miki-data', `miki-editor/posts/${filename}`);
    
    await github.deleteFile(
      'miki-data',
      `miki-editor/posts/${filename}`,
      `Delete ${id}`,
      file.sha
    );
    
    return { id };
  }
};
ğŸ”¥ Phase 3: usePublish í›…
íŒŒì¼: src/hooks/usePublish.js âœ¨ ì‹ ê·œ

javascript
// src/hooks/usePublish.js
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { AuthService } from '../services/auth';
import { PublishService } from '../services/publish';

export function usePublish() {
  const queryClient = useQueryClient();

  const publishMutation = useMutation({
    mutationFn: async (document) => {
      const token = AuthService.getToken();
      const publishService = new PublishService(token);
      return await publishService.publishDocument(document);
    },
    onSuccess: (result, document) => {
      // ë¬¸ì„œ ìƒíƒœ ì—…ë°ì´íŠ¸ (published)
      queryClient.setQueryData(['documents'], (oldData) => {
        if (!Array.isArray(oldData)) return oldData;
        return oldData.map(doc => 
          doc.id === document.id 
            ? { ...doc, isPublished: true, publishedAt: new Date().toISOString() }
            : doc
        );
      });
    }
  });

  const unpublishMutation = useMutation({
    mutationFn: async (document) => {
      const token = AuthService.getToken();
      const publishService = new PublishService(token);
      return await publishService.unpublishDocument(document);
    },
    onSuccess: (result, document) => {
      queryClient.setQueryData(['documents'], (oldData) => {
        if (!Array.isArray(oldData)) return oldData;
        return oldData.map(doc => 
          doc.id === document.id 
            ? { ...doc, isPublished: false, publishedAt: null }
            : doc
        );
      });
    }
  });

  return {
    publish: publishMutation.mutateAsync,
    unpublish: unpublishMutation.mutateAsync,
    isPublishing: publishMutation.isPending,
    isUnpublishing: unpublishMutation.isPending
  };
}
ğŸ”¥ Phase 4: Editor.jsx ì—…ë°ì´íŠ¸ (Publish ë²„íŠ¼ ì—°ê²°)
íŒŒì¼: src/pages/Editor.jsx ğŸ”§ ìˆ˜ì •

javascript
// src/pages/Editor.jsx
// ê¸°ì¡´ importì— ì¶”ê°€
import { usePublish } from '../hooks/usePublish';

function AppContent() {
  // ... ê¸°ì¡´ ì½”ë“œ ...
  
  // âœ… Publish í›… ì¶”ê°€
  const { publish, unpublish, isPublishing, isUnpublishing } = usePublish();
  
  // âœ… Publish í•¸ë“¤ëŸ¬ (ê¸°ì¡´ handlePublish ëŒ€ì²´)
  const handlePublish = useCallback(async () => {
    if (!currentDocument || !currentDocument.id) {
      setMessage({ type: 'warning', text: 'ë°°í¬í•  ë¬¸ì„œë¥¼ ë¨¼ì € ì„ íƒí•˜ê±°ë‚˜ ì €ì¥í•˜ì„¸ìš”.' });
      return;
    }

    if (isPublishing) return;

    try {
      setMessage({ type: 'info', text: 'ë°°í¬ ì¤‘...' });
      
      const result = await publish(currentDocument);
      
      setMessage({ 
        type: 'success', 
        text: `ë°°í¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤! ${result.estimatedDeployTime} í›„ ${result.publicUrl}ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.` 
      });
      
      // ìë™ìœ¼ë¡œ ë©”ì‹œì§€ ì œê±°
      setTimeout(() => setMessage(null), 5000);
    } catch (error) {
      console.error('Publish error:', error);
      setMessage({ 
        type: 'error', 
        text: error.message || 'ë°°í¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' 
      });
    }
  }, [currentDocument, isPublishing, publish]);

  // âœ… Unpublish í•¸ë“¤ëŸ¬
  const handleUnpublish = useCallback(async () => {
    if (!currentDocument || !currentDocument.id) return;

    try {
      setMessage({ type: 'info', text: 'ë°°í¬ ì·¨ì†Œ ì¤‘...' });
      
      await unpublish(currentDocument);
      
      setMessage({ type: 'success', text: 'ë°°í¬ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.' });
      setTimeout(() => setMessage(null), 3000);
    } catch (error) {
      console.error('Unpublish error:', error);
      setMessage({ type: 'error', text: 'ë°°í¬ ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' });
    }
  }, [currentDocument, unpublish]);

  // ... ë‚˜ë¨¸ì§€ ê¸°ì¡´ ì½”ë“œ ê·¸ëŒ€ë¡œ ...
}
ğŸ”¥ Phase 5: github.js ì—…ë°ì´íŠ¸ (íŒŒì¼ CRUD ë©”ì„œë“œ ì¶”ê°€)
íŒŒì¼: src/services/github.js ğŸ”§ ìˆ˜ì •

javascript
// src/services/github.js
// ê¸°ì¡´ ì½”ë“œì— ì¶”ê°€

export class GitHubService {
  // ... ê¸°ì¡´ ë©”ì„œë“œë“¤ ...

  /**
   * íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
   */
  async getFiles(repo, path) {
    try {
      const { data } = await this.octokit.rest.repos.getContent({
        owner: this.username,
        repo: repo,
        path: path
      });
      
      // âœ… ë°°ì—´ì´ ì•„ë‹ˆë©´ ë¹ˆ ë°°ì—´ ë°˜í™˜ (í´ë”ê°€ ì—†ê±°ë‚˜ íŒŒì¼ì¸ ê²½ìš°)
      if (!Array.isArray(data)) return [];
      
      return data;
    } catch (error) {
      if (error.status === 404) return [];
      throw error;
    }
  }

  /**
   * ë‹¨ì¼ íŒŒì¼ ê°€ì ¸ì˜¤ê¸°
   */
  async getFile(repo, path) {
    const { data } = await this.octokit.rest.repos.getContent({
      owner: this.username,
      repo: repo,
      path: path
    });
    
    return {
      content: data.content, // Base64
      sha: data.sha,
      size: data.size,
      path: data.path
    };
  }

  /**
   * íŒŒì¼ ì‚­ì œ
   */
  async deleteFile(repo, path, message, sha) {
    await this.octokit.rest.repos.deleteFile({
      owner: this.username,
      repo: repo,
      path: path,
      message: message,
      sha: sha
    });
  }

  // createOrUpdateFileì€ ì´ë¯¸ ìˆìŒ (SHA ìë™ ì²˜ë¦¬ í¬í•¨)
}
ğŸ“… ì—…ë°ì´íŠ¸ëœ íƒ€ì„ë¼ì¸
Day 2 (ì˜¤ëŠ˜, 11/26 ì˜¤í›„) - 5ì‹œê°„
[2ì‹œê°„] ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ êµ¬í˜„
slugify.js ì‘ì„±

markdown.js ì‘ì„±

metadata.js ì‘ì„±

[2ì‹œê°„] Publish ì„œë¹„ìŠ¤ êµ¬í˜„
publish.js ì‘ì„±

usePublish.js ì‘ì„±

[1ì‹œê°„] storage-client.js ì—…ë°ì´íŠ¸
slugify ì ìš©

ë©”íƒ€ë°ì´í„° ì¶”ì¶œ í†µí•©

Day 3 (11/27) - 6ì‹œê°„
[3ì‹œê°„] Editor í†µí•©
Editor.jsxì— Publish ë²„íŠ¼ ì—°ê²°

handlePublish/handleUnpublish êµ¬í˜„

UI ìƒíƒœ í‘œì‹œ (ë°°í¬ ì¤‘, ë°°í¬ ì™„ë£Œ)

[2ì‹œê°„] í…ŒìŠ¤íŠ¸
ì €ì¥ â†’ íŒŒì¼ëª… í™•ì¸ (slugify ì‘ë™)

Publish â†’ í¼ë¸”ë¦­ ì €ì¥ì†Œ í™•ì¸

GitHub Pagesì—ì„œ ê¸€ í™•ì¸

[1ì‹œê°„] ë²„ê·¸ ìˆ˜ì •
Day 4 (11/28) - 4ì‹œê°„
[2ì‹œê°„] ìµœì¢… ì ê²€
ì „ì²´ í”Œë¡œìš° í…ŒìŠ¤íŠ¸

í¼í¬ë¨¼ìŠ¤ ìµœì í™”

[2ì‹œê°„] ë°°í¬ + ë¬¸ì„œ
Vercel í”„ë¡œë•ì…˜ ë°°í¬

README ì‘ì„±

âœ… ì™„ë£Œ ì¡°ê±´
 ìƒˆ ê¸€ ì €ì¥ ì‹œ íŒŒì¼ëª…ì´ ì œëª©-slug.md í˜•ì‹ìœ¼ë¡œ ìƒì„±ë¨

 Publish ë²„íŠ¼ í´ë¦­ ì‹œ í¼ë¸”ë¦­ ì €ì¥ì†Œì— Jekyll í˜•ì‹ìœ¼ë¡œ ë°°í¬ë¨

 GitHub Pagesì—ì„œ ë°°í¬ëœ ê¸€ì´ ì •ìƒì ìœ¼ë¡œ ë³´ì„

 í”„ë¼ì´ë¹— ì €ì¥ì†Œ(ì›ë³¸) + í¼ë¸”ë¦­ ì €ì¥ì†Œ(ë°°í¬ë³¸) ë‘ ê°œ ëª¨ë‘ ê´€ë¦¬ë¨

 ë©”íƒ€ë°ì´í„°(ì œëª©, íƒœê·¸, ë§í¬) ìë™ ì¶”ì¶œ ë° ê´€ë¦¬ë¨

ğŸ¯ í•µì‹¬ ì°¨ì´ì  (ê¸°ì¡´ ê³„íš vs. v2.0)
í•­ëª©	ê¸°ì¡´ ê³„íš	v2.0 (ì™„ì „íŒ)
ì €ì¥ì†Œ êµ¬ì¡°	í”„ë¼ì´ë¹—ë§Œ ì‚¬ìš©	âœ… í”„ë¼ì´ë¹— + í¼ë¸”ë¦­
Publish ê¸°ëŠ¥	ì—†ìŒ (404 ì—ëŸ¬)	âœ… ì™„ì „ êµ¬í˜„
íŒŒì¼ëª…	memo-timestamp	âœ… slugify(ì œëª©)
ë©”íƒ€ë°ì´í„°	ì—†ìŒ	âœ… ì œëª©/íƒœê·¸/ë§í¬ ê´€ë¦¬
UX/ë¡œì§	ë‹¨ìˆœí™”ë¨	âœ… ë°±ì—”ë“œ ë¡œì§ 100% ë³´ì¡´